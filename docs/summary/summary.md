

## 一、认识Python

人生苦短，我用 Python —— Life is short, you need Python

![image-20201228094108679](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120144048.png)



### 1.1 Python的起源

Python 的创始人为吉多·范罗苏姆（Guido van Rossum）

![image-20201228094210879](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120144719.png)

1989 年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的解释程序，作为 ABC 语言的一种继承

ABC 是由吉多参加设计的一种教学语言，就吉多本人看来，ABC 这种语言非常优美和强大，是专门为非专业程序员设计的。但是ABC语言并没有成功，究其原因，吉多认为是非开放造成的。吉多决心在 Python 中避免这一错误，并获取了非常好的效果

之所以选中 Python（蟒蛇）作为程序的名字，是因为他是 BBC 电视剧——蒙提·派森的飞行马戏团（Monty Python's Flying Circus）的爱好者

1991 年，第一个 Python 解释器诞生，它是用 C 语言实现的，并能够调用 C 语言的库文件

`Python 2.0` 于 2000 年 10 月 16 日发布，增加了实现完整的垃圾回收，并且支持 Unicode。

`Python 3.0` 于 2008 年 12 月 3 日发布，此版不完全兼容之前的 Python 源代码。不过，很多新特性后来也被移植到旧的 `Python 2.6/2.7` 版本。

### 1.2 Python的设计目标

1999 年，吉多·范罗苏姆向 DARPA 提交了一条名为 “Computer Programming for Everybody” 的资金申请，并在后来说明了他对 Python 的目标：

- 一门简单直观的语言并与主要竞争者一样强大
- 开源，以便任何人都可以为它做贡献
- 代码像纯英语那样容易理解
- 适用于短期开发的日常任务

这些想法中的基本都已经成为现实，Python 已经成为一门流行的编程语言

### 1.3 Python的设计哲学

- 优雅
- 明确
- 简单

Python 开发者的哲学是：用一种方法，最好是只有一种方法来做一件事

如果面临多种选择，Python 开发者一般会拒绝花俏的语法，而选择明确没有或者很少有歧义的语法

在 Python 社区，吉多被称为“仁慈的独裁者”

在Python解释器下输入

```python
import this
```

会出来这样一首小诗：

```text
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
```

- `Beautiful is better than ugly`

整齐、易读胜过混乱、晦涩

- `Simple is better than complex`

简约胜过复杂

- `Complex is better than complicated`

复杂胜过晦涩

- `Flat is better than nested`

扁平胜过嵌套

- Now is better than never.
- Although never is often better than *right* now.

先行动起来，编写行之有效的代码，不要企图一开始就编写完美无缺的代码

做比不做要好，但是盲目的不加思考的去做还不如不做

- If the implementation is hard to explain, it's a bad idea.
- If the implementation is easy to explain, it may be a good idea.

如果方案很难解释，很可能不是有一个好的方案，反之亦然

### 1.4 为什么选择 Python？

- 代码量少
- ……

同一样问题，用不同的语言解决，代码量差距还是很多的，一般情况下 Python 是 Java 的 1/5，所以说 人生苦短，我用 Python

#### 1.4.1 Python特点

1. Python 是完全面向对象的语言

   函数、模块、数字、字符串都是对象

   在 Python 中一切皆对象完全支持继承、重载、多重继承支持重载运算符，也支持泛型设计 

2. Python 拥有一个强大的标准库

   Python 语言的核心只包含 数字、字符串、列表、字典、文件等常见类型和函数，而由 Python 标准库提供了 系统管理、网络通信、文本处理、数据库接口、图形系统、XML 处理等额外的功能

3. Python 社区提供了大量的第三方模块，使用方式与标准库类似。它们的功能覆盖 科学计算、人工智能、机器学习、Web 开发、数据库接口、图形系统 多个领域

4. 面向对象的思维方式

- 面向对象 是一种 思维方式，也是一门 程序设计技术
- 要解决一个问题前，首先考虑 由谁来做，怎么做事情是 谁 的职责，最后把事情做好就行！
- 对象就是谁
- 要解决复杂的问题，就可以找多个不同的对象，各司其职，共同实现，最终完成需求

#### 1.4.2 Python的优缺点

- 优点

  - 简单、易学
  - 免费、开源
  - 面向对象
  - 丰富的库
  - 可扩展性
  - 如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把这部分程序用 C 或 C++ 编写，然后在 Python 程序中使用它们

  

- 缺点

  - 运行速度
  - 国内市场较小
  - 中文资料匮乏

## 二、 编译器和解释器

计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。将其他语言翻译成机器语言的工具，被称为编译器

编译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译时间点的不同。当编译器以解释方式运行的时候，也称之为解释器

![img](https://gitee.com/zgf1366/pic_store/raw/master/img/20210201085128.webp)

### 2.1 编译型语言

程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++，缺点不能跨平台，开发速度慢（将代码一次性全部转化成字节码）

### 2.2 解释型语言

解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行

优点：开发效率高，便于调试，可以跨平台

缺点：执行速度相对低（代码从上至下逐行解释）

Python解释器 Cpython，Jpython，Ironpython，pypy…



### 2.3 编译型语言和解释型语言对比

- 速度 —— 编译型语言比解释型语言执行速度快
- 跨平台性 —— 解释型语言比编译型语言跨平台性好

## 三、编码方式

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/summary/coding.py)

### 3.1 字符编码说明

字符编码这个知识点其实只是涉及到一行代码，但是它非常重要，据不完全统计，现在软件30%的损失都是由于乱码问题所导致的，这个问题是最容易被大家所忽视的，因为使用的时候只是一行代码的问题，但是它的里面包含很多的知识，大部分人更加倾向于直接掌握结果，而不考虑它内部的知识，这就导致了一旦遇到字符编码的乱码问题，就会手足无措。你之前可能看过一些相关的介绍，正确与否我们先不做评论，在这篇文章中，我们会对字符编码进行全方位的介绍。字符编码的特点是理论非常多，而结论非常少，但是如果不知道理论，结论可能永远也无法理解，而且以后遇到字符编码问题就会不知所措。

### 3.2 编码种类

#### 3.2.1 ASCII

最初版本的密码本：所有的英文字母，数字，特殊字符。

ASCII编码用单字节表示字符，最高位固定为0，故最多只能表示128个字符，当编程只涉及到英文字符或数字时，不涉及中文字符时，可以使用ASCII编码。

ASCII最左边为0，为当时设计师预留的一位，设计师认为七位足可以表示英文+数字+特殊字符

#### 3.2.2 unicode

万国码，将所有国家的语言文字都写入这个密码本

在文本文件中，看到的所有字符，包括中文，都需要在计算机中存储，而计算机只能存储0和1这样的二进制位，所以需要一种方法，将字符映射成数字，然后将数字转化为二进制位存储在计算机中。针对字符和数字的映射的问题，产生了unicode编码。

unicode将世界上的所有字符映射为唯一的数字。unicode数字并不是直接就可以转化为二进制存储，比如假设中文字符‘中’映射为数字1（00000001），‘国’映射为数字2（00000010），由于汉字很多，单字节并不能表示完所有的汉字，故可能会有汉字的unicode数字为258（00000001 00000010），假设为‘京’，现在在字符串中碰到存储为00000001 00000010的二进制串，不能区分出其实际代表的是“中国”还是“京”。

#### 3.2.3 UTF-8

最少用8位表示一个字符

和GB系列不同，UTF-8可以将全世界所有的unicode数字表示出来。`UTF-8兼容ASCII编码，不兼容GB系列编码`，因此，若文本中UTF-8和GB系列编码混用，会出现乱码问题。UTF-8对于每个字符的存储，用最高二进制位开始连续1的个数表示字的长度，最高位为0表示单字节，用来兼容ASCII字符，为110表示双字节，非字符首字节的字节都以10开始，如下表格所示。例如：字符‘中’的unicode编码为2D4E(00101101 01001110),用UTF-8存储的二进制为E4B8AD(11100100 10111000 10101101 )，存储在计算机中的首字节为1110开头，表示此字符占三个字节，去掉开始字节表示长度的1110和其余字节开头的10，可以得到01001110 00101101(4E2D)，可以看到和unicode数字刚好相反，是因为是大端存储方式，高字节存储在内存中的低地址端，反过来即为unicode编码。

#### 3.2.4 GBK

国标，只包含中文，英文（英文，数字，特殊字符）

GB(GuoBiao)为国标，GBK(GuoBiao Kuozhan)表示国标扩展。GB2312兼容ASCII编码，对于ASCII可以表示的字符，如英文字符‘A’、‘B’等，在GB2312中的编码和ASCII编码一致，占一个字节，对于ASCII不能表示的字符，GB2312用两个字节表示，且最高位不为0，以防和ASCII字符冲突。例如：‘A’在GB2312中存储的字节十六进制为41，在ASCII中也是41，中文字符‘中’在GB2312中存储的两个字节十六进制为D6D0，最高位为1不为0。

GB2312只有6763个汉字，而汉字特别多。GBK属于GB2312的扩展，增加了很多汉字，同时兼容GB2312，同样用两个字节表示非ASCII字符。

###  3.3 字节码

Pyc文件：C 是 compiled编译过的意思

1. 浏览程序目录会发现一个 pycache 的目录

2. 目录下会有一个 .cpython-35.pyc 文件，cpython-35 表示 Python 解释器的版本

3. 这个 pyc 文件是由 Python解释器将 模块的源码转换为字节码

4. Python 这样保存字节码是作为一种启动速度的优化

**字节码**

- Python在解释源程序时是分成两个步骤的
- 1. 首先处理源代码，编译生成一个二进制字节码
  2. 再对字节码进行处理，才会生成 CPU 能够识别的机器码
- 有了模块的字节码文件之后，下一次运行程序时，如果在上次保存字节码之后没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤
- 当 Python 重编译时，它会自动检查源文件和字节码文件的时间戳
- 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建

### 3.4 文件头

Python 2.x 默认使用 `ASCII` 编码格式
Python 3.x 默认使用 `UTF-8` 编码格式

- 在 Python 2.x 文件的第一行增加以下代码，解释器会以 `utf-8` 编码来处理 python 文件

```python
# *-* coding:utf8 *-*
```

这方式是官方推荐使用的！

- 也可以使用

```python
# coding=utf8
```

### 3.5 乱码问题的产生与解决

#### 3.5.1 乱码问题的成因



内存中的编码都是Unicode，如果忽略硬盘，在内存中随便写什么编码都不会出现乱码，但是因为硬盘的存在就会出现由内存向硬盘保存的时候你要指定一个字符编码，比如说是GBK，这时就是由Unicode转化成GBK，当把这个硬盘文件重新在内存读取的时候你也要告诉计算机按照GBK编码来读取，它才会对应的把数据由GBK编码反解成Unicode编码写入到内存。如果你在这时告诉你计算机用ASCII的标准来反解数据，那么就无法反解出原来保存的数据内容，计算机懵圈了，呈现给你的就是它懵圈后的结果。

#### 3.5.2 保证不乱码的方案

保证不出现乱码问题其实结论就只有一个：文件用什么编码保存的，就用什么编码读取，注意：我们能控制的只是文件由内存保存到硬盘的编码。

编写python程序时，为避免不同类型字符串混用出现编解码异常，要把编码和解码操作放在程序的最外围来做，程序的核心逻辑统一使用unicode字符类型。



## 四、执行程序的方式

### 4.1 Python 源程序的基本概念 

1. Python 源程序就是一个特殊格式的文本文件，可以使用任意文本编辑软件做 `Python` 的开发
2. Python 程序的 文件扩展名 通常都是 `.py`

### 4.2 python中的计数方法

常见的计数方法有两种，可以分别称为：

- **自然计数法**（从 1 开始）—— 更符合人类的习惯
- **程序计数法**（从 0 开始）—— 几乎所有的程序语言都选择从 0 开始计数

因此，大家在编写程序时，应该尽量养成习惯：`除非需求的特殊要求，否则 循环 的计数都从 0 开始`

### 4.3 解释器 python / python3

Python 的解释器

```bash
# 使用 python 2.x 解释器
$ python xxx.py
 
# 使用 python 3.x 解释器
$ python3 xxx.py
```

- - 为了不带入过多的累赘，Python 3.0 在设计的时候 没有考虑向下兼容
  - 许多早期 Python 版本设计的程序都无法在 Python 3.0 上正常执行

#### python2x与python3x区别

- python2x:

  源码重复，不规范；默认编码ASCII，不支持中文，如果想显示中文，需在首行添加 # -*-encoding：utf-8 -*-。

- python3x:

  源码规范，优美，清晰，简单；默认编码utf-8。

#### 其他解释器

Python的解释器 如今有多个语言的实现，包括：

- `CPython` —— 官方版本的 C 语言实现
- `Jython` —— 可以运行在 Java 平台
- `IronPython` —— 可以运行在 .NET 和 Mono 平台
- `PyPy` —— Python 实现的，支持 JIT 即时编译

### 4.4 交互式运行 Python 程序

直接在终端中运行解释器，而不输入要执行的文件名

#### 4.4.1 Python Shell

- 在 Python 的 Shell 中直接输入 Python 的代码，会立即看到程序执行结果

**a. 交互式运行 Python 的优缺点**

​	优点

​		适合于学习/验证 Python 语法或者局部代码

​	缺点

​		代码不能保存

​		不适合运行太大的程序

**b. 退出 官方的解释器**

- 直接输入 `exit()`

```bash
exit()
```

- 使用热键退出：在 python 解释器中，按热键 `ctrl + d` 可以退出解释器

#### 4.4.2 IPython

- IPython 中 的 “I” 代表 交互 **interactive**

**a. 特点**

- IPython 是一个 python 的 交互式 shell，比默认的 `python shell` 好用得多

  ​	支持自动补全

  ​	自动缩进

  ​	支持 `bash shell` 命令

  ​	内置了许多很有用的功能和函数

- IPython 是基于 BSD 开源的

**b. 版本**

​	Python 2.x 使用的解释器是 **ipython**

​	Python 3.x 使用的解释器是 **ipython3**

**c. 退出 官方的解释器**

1> 直接输入 `exit`

```bash
exit
```

2> 使用热键退出：在 IPython 解释器中，按热键 `ctrl + d`，`IPython` 会询问是否退出解释器

- IPython 的安装

```bash
$ sudo apt install ipython
```

**d. Ipython notebook**

在命令行下输入命令：

```py
ipython notebook 
```

会打开一个notebook本地服务器，一般地址是 [http://localhost:8888](http://localhost:8888)

ipython notebook 支持两种模式的cell：

*   Markdown
*   Code

### 4.5 Python 的 IDE —— PyCharm

#### 4.5.1 集成开发环境（IDE）

集成开发环境（`IDE`，Integrated Development Environment）—— 集成了开发软件需要的所有工具，一般包括以下工具：

- 图形用户界面
- 代码编辑器（支持 代码补全／自动缩进）
- 编译器／解释器
- 调试器（断点／单步执行）
- ……

#### 4.5.2 PyCharm 介绍

- PyCharm 是 Python 的一款非常优秀的集成开发环境

- PyCharm 除了具有一般 IDE 所必备功能外，还可以在 Windows、Linux、macOS 下使用

- PyCharm 适合开发大型项目

- - 一个项目通常会包含 很多源文件
  - 每个 源文件 的代码行数是有限的，通常在几百行之内
  - 每个 源文件 各司其职，共同完成复杂的业务功能

#### 4.5.3 PyCharm 快速体验

![clip_image004](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120145401.png)



- **文件导航区域** 能够 浏览／定位／打开 项目文件

- **文件编辑区域** 能够 编辑 当前打开的文件

- **控制台区域** 能够：

- - 输出程序执行内容
  - 跟踪调试代码的执行

- 右上角的 **工具栏** 能够 执行(SHIFT + F10)/ 调试(SHIFT + F9) 代码

![clip_image006](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120145437.png)

- 通过控制台上方的**单步执行按钮(F8)**，可以单步执行代码

![clip_image008](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120145540.png)

左边三角表示执行全部程序

## 五、程序运行原理

### 5.1 计算机中的三大件

计算机中包含有较多的硬件，但是一个程序要运行，有 三个核心的硬件，分别是：

1. `CPU`

   - 中央处理器，是一块超大规模的集成电路

   - 负责 处理数据／计算（负责执行程序）

2. `内存`

   - 临时存储数据（断电之后，数据会消失）

   - 速度快
   - 空间小（单位价格高）
   - 内存条通常只有 4G / 8G / 16G / 32G

3. `硬盘`

   - 永久存储数据

   - 速度慢
   - 空间大（单位价格低）
   - 程序安装在硬盘中


|                             CPU                              |                             内存                             |                             硬盘                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![clip_image002](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120145926.jpg) | ![clip_image0014](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120145913.png) | ![clip_image006](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120145919.jpg) |

### 5.2 程序执行的原理

![img](https://gitee.com/zgf1366/pic_store/raw/master/img/20210201093335.png)

1. 程序运行之前，程序是保存在硬盘中的
2. 当要运行一个程序时,操作系统会首先让CPU把程序复制到内存中
3. CPU执行内存中的程序代码


`程序要执行，首先要被加载到内存`

- Python程序执行原理

1. 操作系统会首先让 CPU 把 Python 解释器 的程序复制到 内存 中
2. Python 解释器 根据语法规则，从上向下 让 CPU 翻译 Python 程序中的代码
3. CPU 负责执行翻译完成的代码

- Python 的解释器有多大？

  执行以下终端命令可以查看 Python 解释器的大小

```bash
# 1. 确认解释器所在位置
$ which python
# 2. 查看 python 文件大小(只是一个软链接)
$ ls -lh /usr/bin/python
# 3. 查看具体文件大小
$ ls -lh /usr/bin/python2.7
```

提示：建立 软链接 的目的，是为了方便使用者不用记住使用的解释器是 哪一个具体版本

### 5.3 程序的作用

`程序就是用来处理数据的，而变量就是用来存储数据的`

- 新闻软件提供的新闻内容、评论……是数据
- 电商软件提供的商品信息、配送信息…… 是数据
- 运动类软件提供的运动数据…… 是数据
- 地图类软件提供的地图信息、定位信息、车辆信息…… 是数据
- 即时通讯软件提供的聊天信息、好友信息……是数据
- ……

**思考 QQ 程序的启动过程**

1. QQ 在运行之前，是保存在硬盘中的
2. 运行之后，QQ 程序就会被加载到内存中了

![clip_image012](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150115.png)

**思考QQ程序的登录过程**

1. 读取用户输入的 QQ 号码
2. 读取用户输入的 QQ 密码
3. 将 QQ 号码 和 QQ 密码 发送给腾讯的服务器，等待服务器确认用户信息

思考 1：在 QQ 这个程序将 QQ 号码 和 QQ 密码 发送给服务器之前，是否需要先存储一下 QQ 号码 和 密码?

答：肯定需要！—— 否则 QQ 这个程序就不知道把什么内容发送给服务器了！

思考 2：QQ 这个程序把 QQ号码和 QQ 密码 保存在哪里？

答：保存在 内存 中，因为 QQ 程序自己就在内存中

思考 3：QQ 这个程序是怎么保存用户的 QQ号码 和 QQ 密码 的？

答：

1. 在内存中为 QQ号码 和 QQ密码 各自分配一块空间

2. - 在 QQ 程序结束之前，这两块空间是由 QQ 程序负责管理的，其他任何程序都不允许使用
   - 在 QQ 自己使用完成之前，这两块空间始终都只负责保存 QQ号码 和 QQ密码

3. 使用一个 别名 标记 QQ号码 和 QQ密码 在内存中的位置

![clip_image014](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150140.jpg)

在程序内部，为 QQ号码和 QQ密码 在内存中分配的空间就叫做 变量

### 5.4 进制转换

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/summary/base_conversion.py)

十进制 二进制0b、八进制0o、十六进制0x

|   ↓    |     2进制     |     8进制     |     10进制     |     16进制     |
| :----: | :-----------: | :-----------: | :------------: | :------------: |
| 2进制  |       -       | bin(int(n,8)) | bin(int(n,10)) | bin(int(n,16)) |
| 8进制  | oct(int(n,2)) |       -       | oct(int(n,10)) | oct(int(n,16)) |
| 10进制 |   int(n,2)    |   int(n,8)    |       -        |   int(n,16)    |
| 16进制 | hex(int(n,2)) | hex(int(n,8)) | hex(int(n,10)) |       -        |

`原理：python内置函数进行进制转换的原理是将读入的一个字符串(python默认读入的都是字符串形式)转为10进制，然后再用相关函数进行其他进制转换`

#### 5.4.1 2进制转换成其他进制

**2进制转换成8进制：oct(int(n,2))**

```python
n=input()
print(oct(int(n,2)))
```

输入: 1010
输出: 0o12

**2进制转换成10进制：int(n,2)**

```python
n=input()
print(int(n,2))
```

输入：1010
输出：10

**2进制转换成16进制：hex(int(n,2))**

```python
n=input()
print(hex(int(n,2)))
```

输入：1010
输出：0xa

#### 5.4.2 8进制转换成其他进制

**8进制转换成2进制：bin(int(n,8))**

```python
n=input()
print(bin(int(n,8)))
```

输入：1010
输出：0b1000001000

**8进制转换成10进制：int(n,8)**

```python
n=input()
print(int(n,8))
```

输入：1010
输出：520

**8进制转换成16进制：hex(int(n,16))**

```python
n=input()
print(hex(int(n,8)))
```

输入：1010
输出：0x208

#### 5.4.3 10进制转换成其他进制

说明：10进制转换可以直接采取上述表格中的形式，读入字符串，先转换为10进制的数，再用函数进行操作转换成其他进制。
但同时可以这样操作，读入的时候直接进行强制类型转换操作，转为int类型(python中的int类型的数据就是10进制)

**10进制转换成2进制：bin(n)**

```python
n=int(input())
print(bin(n))
```

输入：10
输出：0b1010

**10进制转换成8进制：oct(n)**

```python
n=int(input())
print(oct(n))
```

输入：10
输出：0o12

**10进制转换成16进制：hex(n)**

```python
n=int(input())
print(hex(n))
```

输入：10
输出：0xa

#### 5.4.4 16进制转换成其他进制

**16进制转换成2进制：bin(int(n,16))**

```python
n=input()
print(bin(int(n,16)))
```

输入：a
输出：0b1010

**16进制转换成8进制：oct(int(n,16))**

```python
n=input()
print(oct(int(n,16)))
```

输入：a
输出：0o12

**16进制转换成10进制：int(n,16)**

```python
n=input()
print((int(n,16)))
```

输入：a
输出：10

**注意**：我们可以发现，除了转换成10进制的数，其他的进制转换结果都带有前缀，2进制是0b，8进制是0o，16进制是0x。但是我们在绝大部分使用进制转换后的数据时，是不需要它的前缀的。

#### 5.4.5 使用字符串切片操作去掉前缀

**原理**：就是将进制转换后得到的结果对其进行字符串切片操作，将得到的结果从第三个字符开始取结果即可，这样我们可以得到不带前缀的结果

**举例：**

```python
//10进制转换成2进制
n=int(input())
print(bin(n)[2:])//切片操作
```

输入：10
输出：1010

```python
//10进制转换成8进制
n=int(input())
print(oct(n)[2:])//切片操作
```

输入：10
输出：12

```python
//10进制转换成16进制
n=int(input())
print(hex(n)[2:])//切片操作
```

输入：10
输出：a

其他的情况类比即可。

#### 5.4.5 使用format函数进行格式化数字操作去掉前缀

**说明**：前面说过，不同类型的进制转换的原理时先转换为十进制，然后再用相关的函数进行进制转换操作，而format函数里面有格式化数字的方法可以直接实现进制转换的功能，下面一一介绍：

**其他类型转换为2进制：**
**操作**：在format函数的槽中添加一个b 即可实现其他类型对2进制的转换，下面举例说明

```python
n=input()
print("{:b}".format(int(n,8)))
//先将8进制的数转换为10进制，
//然后在format的槽中添加一个b，等价于实现了bin函数的功能
//但是此结果是不带有0b前缀的
```

输入：1010
输出：1000001000

**其他类型转换为8进制：**

**操作**：在format函数的槽中添加一个o 即可实现其他类型对8进制的转换，下面举例说明

```python
n=input()
print("{:o}".format(int(n,16)))
//先将一个16进制数转换为10进制
//然后利用format函数格式化数字方法转换即可
```

输入：a
输出：12

**其他类型转换为16进制：**
**操作**：在format函数的槽中添加一个x 即可实现其他类型对2进制的转换，下面举例说明

```python
n=input()
print("{:x}".format(int(n,8)))
//先将一个8进制的数转换为16进制
//然后原理同上
```

输入：1010
输出：208

注意：由于转换成10进制本来就是不带前缀的，无需用format格式化数字方法控制

### 5.5 单位转换

8 bit == 1bytes

1024bytes==kb

1024kb==1MB

1024MB==1GB

1024GB==1TB

1024TB==1PB

## 六、代码块和小数据池

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/summary/data_pool.py)

### 6.1 代码块

Python程序是由代码块构造的。块是一个python程序的文本，他是作为一个单元执行的。

代码块：一个模块，一个函数，一个类，一个文件等都是一个代码块。

而作为交互方式输入的每个命令都是一个代码块。

如果在同一代码块下，则采用同一代码块下的缓存机制。

- 代码块的缓存机制

`前提条件：在同一个代码块内。`

机制内容：Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用。换句话说：执行同一个代码块时，遇到初始化对象的命令时，他会将初始化的这个变量与值存储在一个字典中，在遇到新的变量时，会先在字典中查询记录，如果有同样的记录那么它会重复使用这个字典中的之前的这个值。文件执行时（同一个代码块）会把i1、i2两个变量指向同一个对象，满足缓存机制则他们在内存中只存在一个，即：id相同。

适用对象： int（float），str，bool。

对象的具体细则：

　　int(float):任何数字在同一代码块下都会复用。

　　bool:True和False在字典中会以1，0方式存在，并且复用。

　　str：几乎所有的字符串都会符合缓存机制，具体规定如下：

1.非乘法得到的字符串都满足代码块的缓存机制：

```python
s1 = '太白@！#*ewq'
s2 = '太白@！#*ewq'
print(s1 is s2)  # True
```

2.乘法得到的字符串分两种情况：

2.1 乘数为1时，任何字符串满足代码块的缓存机制：

```python
b1 = '太白@5847395QQ0743895*&^%$#((&_+(())' *1
a1 = '太白@5847395QQ0743895*&^%$#((&_+(())' *1
print(a1 is b1)  # True
```

2.2 乘数>=2时：仅含大小写字母，数字，下划线，总长度<=20，满足代码块的缓存机制：

```python
s1 = 'old_' * 5
s2 = 'old_' * 5
print(s1 is s2)  # True
```

**优点**：能够提高一些字符串，整数处理任务在时间和空间上的性能；需要值相同的字符串，整数的时候，直接从‘字典’中取出复用，避免频繁的创建和销毁，提升效率，节约内存。

### 6.2 小数据池

小数据池就是Python中一种提高效率的方式,也叫缓存机制，驻留机制。不同代码块的缓存机制，固定数据类型使用同一个内存地址 小数池 -- 支持: str,int,bool

如果是不同代码块，则采用小数据池的驻留机制。

`前提条件：在不同一个代码块内。`

机制内容：

​	Python自动将-5~256的整数进行了缓存，当你将这些整数赋值给变量时，并不会重新创建对象，而是使用已经创建好的缓存对象。

python会将一定规则的字符串在字符串驻留池中，创建一份，当你将这些字符串赋值给变量时，并不会重新创建对象， 而是使用在字符串驻留池中创建好的对象。

其实，无论是缓存还是字符串驻留池，都是python做的一个优化，就是将~5-256的整数，和一定规则的字符串，放在一个‘池’（容器，或者字典）中，无论程序中那些变量指向这些范围内的整数或者字符串，那么他直接在这个‘池’中引用，言外之意，就是内存之中创建一个。

适用对象： int（float），str，bool

对象的具体细则：

**int**：那么大家都知道对于整数来说，小数据池的范围是-5~256 ，如果多个变量都是指向同一个（在这个范围内的）数字，他们在内存中指向的都是一个内存地址。

![988316-20180808200847930-504994378](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150223.png)

**str:**字符串要从下面这几个大方向讨论：

1.字符串的长度为0或者1，默认都采用了驻留机制（小数据池）。

![988316-20180808201330161-1470862471](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150239.png)

![img](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150414.png)

2.字符串的长度>1,且只含有大小写字母，数字，下划线时，才会默认驻留。

![988316-20180808201628603-631716317](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150433.png)

3.用乘法得到的字符串，分两种情况。

3.1 乘数为1时：

仅含大小写字母，数字，下划线，默认驻留。

![988316-20180808202136263-972264368](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150449.png)

含其他字符，长度<=1,默认驻留。

![988316-20180808202316229-779316774](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150515.png)

含其他字符，长度>1,默认驻留。

![988316-20180808202425137-1836179125](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150532.png)

3.2 乘数>=2时：

仅含大小写字母，数字，下划线，总长度<=20,默认驻留。

![988316-20180808202839323-1987776954](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150546.png)

4. 指定驻留

```python
from sys import intern
a = intern('hello!@'*20)
b = intern('hello!@'*20)
print(a is b)
#指定驻留是你可以指定任意的字符串加入到小数据池中，让其只在内存中创建一个对象，多个变量都是指向这一个字符串。
```

满足以上字符串的规则时，就符合小数据池的概念。

bool值就是True，False，无论你创建多少个变量指向True，False，那么他在内存中只存在一个。

看一下用了小数据池（驻留机制）的效率有多高：

显而易见，节省大量内存在字符串比较时，非驻留比较效率o(n)，驻留时比较效率o(1)。

![20180405084648_2eb605762effbc71c9f74d3e6410b761_2](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150606.jpeg)

优点：能够提高一些字符串，整数处理任务在时间和空间上的性能；需要值相同的字符串，整数的时候，直接从‘池’里拿来用，避免频繁的创建和销毁，提升效率，节约内存

